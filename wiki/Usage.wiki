#labels Featured
This library aims to simplify late binding calls in C#, which are painfully complex in C# specially if we compare it with how VB.NET handles late binding calls.
With C#4.0 the *dynamic* keyword will be added so -with time- this library will be deprecated. But C# 4.0 isn't out yet, and even when it comes out, there will be still  a lot of projects using previous versions of the language which can benefit from this library.

= Introduction: Early binding & Late binding =

In a early binding call we specify an operation and, if the signature for that operation is correct, the compiler binds the code for that operation at compile time. E.g:
{{{
int result = calculator.Add( 15, 16 )
}}}
When this code is build the C# compiler checks if the calculator object instance defines an operation with the name 'Add', that takes 2 integers as parameters, and returns  another integer. If the operation with that concrete signature is found for the calculator object, the compiler _binds_ that call to the actual code which performs the operation. Otherwise a compile-time error is issued as the compiler can't find an operation matching that signature.
All of this is possible because the compiler has information about the calculator object instance type.

But, what if we don't have that information? 
That could happen with interop scenarios (e.g. getting a COM object which exists outside the .NET Framework, Maybe we have the specs defining the operations the object exports, but we can have the compiler reference that information).
How do we made calls if the compiler doesn't have that information?
That's where the _late binding_ calls make their appearance. 

With a late binding call, the binding to the actual code -searching for the operation with that signature- is postponed to runtime, when we have more information about the type.

That implies that no type checks can be performed at compile time using late binding calls as we did't have type information in first place. As a consequence, if we call an operation in a object instance using late bindind and no operation matching signature is found, a failure will occur, but the important thing to remember is that *it will show up at runtime*

= Details =

All late binding functionality is based on the interface 'LateBindingHelper.ILateBindingFacade'

Adquisition of 'ILateBinding' interfaces is done using a Factory static class:
The 'LateBindingFactory.CreateObjectBinding' allows creation of a 'ILateBindingFacade' given an instance of an object, or using the 'System.Type' for the object:
{{{
MyClass myClassInstance = new MyClass();

//Late Binding calls will be dispatched to the myClassInstance object

ILateBindingFactory lbf1 = LateBindingFactory.CreateObjectLateBinding( myClassInstance );

//Creates a new MyClass object instance where the late binding call will be dispatched 
//using the default constructor
ILateBindingFactory lbf2 = LateBindingFactory.CreateObjectLateBinding( typeof(MyClass) );

int integerArgument = 2008;
//Creates a new MyClass object instance where the late binding call will be dispatched passing
//arguments to the constructor
ILateBindingFactory lbf3 = LateBindingFactory.CreateObjectLateBinding( typeof(MyClass),  integerArgument );
}}}

The 'LateBindingObject.CreateAutomationLateBinding(') factory makes a binding to an Automation aplication given its Running Object Table (ROT) name:
{{{
ILateBindingFactory word = LateBindingFactory.CreateAutomationLateBinding("word.application");
}}}

Once we have an instance of an ILateBindingFacade inteface, we can send any operation we want 
to the object using late binding:

* Call a method:

{{{
//Method call without parameters and no return value
myLateBindingFacade.Call("Method1");

//Method call with parameters and no return value (or we don't need the return value)
int arg1 = 1;
double arg2 = 2.3;
myLateBindingFacade.Call( "Method2", Args.Build(arg1, arg2) );

//Method call without parameters and a return value
int result;
result = myLateBindingFacade.Call<int>("Method3");
result = (int)myLateBindingFacade.Call<object>("Method3");

//Method call with parameters and a return value
int result;
int arg1 = 1;
double arg2 = 2.3;
result = myLateBindingFacade.Call<int>("Method2", Args.Build(arg1, arg2));
result = (int)myLateBindingFacade.Call<object>("Method2", Args.Build(arg1, arg2));
}}}

* Call a method with reference parameters:
{{{
int refParam = 10;
double notRefParam1 = 20;
bool notRefParam2 = true;

//Save the arguments
object[] args = Args.Build(notRefparam1, notRefParam2, refValue);

//Make the call. Args.ByRefIndexs indicates the index number of the arguments
//which are passed as reference
myLateBindingFacade.Call("MultiplyByFive", Args.ByRefIndexs(2), args);

//Recover the new value for the parameter passed by reference
refValue = (int)args[2];
}}}

* Property or field access:
{{{
//Get property value
bool boolResult;
boolResult = myLateBindingFacade.Get<bool>("Property1");
boolResult = (bool)myLateBindingFacade.Get("Property1");

//Get field value
int intResult;
intResult = myLateBindingFacade.Get<int>("field1");
intResult = (int)myLateBindingFacade.Get("field1");

//Set property value
myLateBindingFacade.Set("Property1", true);

//Set field value
myLateBindingFacade.Set("field1", 10);
}}}

* Index accessing or assignament:
{{{
string result;
result = myLateBindingFacade.GetIndex<string>(5);
myLateBindingFacade.SetIndex(4, "[myNewValue]");
}}}